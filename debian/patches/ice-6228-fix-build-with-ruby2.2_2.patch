Description: patch [2 of 2] to fix the build with ruby2.2
Origin: https://github.com/zeroc-ice/ice/commit/e55ff293f56d18810e73c1495c0a93c2372735cc
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=791848
From e55ff293f56d18810e73c1495c0a93c2372735cc Mon Sep 17 00:00:00 2001
From: Jose <jose@zeroc.com>
Date: Tue, 10 Feb 2015 11:24:32 +0100
Subject: Simplify fix for (ICE-6288) to not depend on ruby internals
Last-Updated: 2015-11-21

---
 rb/src/IceRuby/Config.h | 102 ------------------------------------------------
 rb/src/IceRuby/Util.cpp |  99 +++++++++++++++++++++-------------------------
 2 files changed, 45 insertions(+), 156 deletions(-)

diff --git a/rb/src/IceRuby/Config.h b/rb/src/IceRuby/Config.h
index f7b0bef..82e755a 100644
--- a/rb/src/IceRuby/Config.h
+++ b/rb/src/IceRuby/Config.h
@@ -36,87 +36,6 @@
 
 
 #include <ruby.h>
-#include <ruby/version.h>
-
-#if defined(RUBY_API_VERSION_CODE) && RUBY_API_VERSION_CODE >= 20200
-//
-// Since ruby 2.2.0 the macros to convert Bignum to long are 
-// not public. We define here our own version.
-//
-# ifndef BDIGIT
-#  if SIZEOF_INT*2 <= SIZEOF_LONG_LONG
-#   define BDIGIT unsigned int
-#   define SIZEOF_BDIGIT SIZEOF_INT
-#   define BDIGIT_DBL unsigned LONG_LONG
-#  elif SIZEOF_INT*2 <= SIZEOF_LONG
-#   define BDIGIT unsigned int
-#   define SIZEOF_BDIGIT SIZEOF_INT
-#   define BDIGIT_DBL unsigned long
-#  elif SIZEOF_SHORT*2 <= SIZEOF_LONG
-#   define BDIGIT unsigned short
-#   define SIZEOF_BDIGIT SIZEOF_SHORT
-#   define BDIGIT_DBL unsigned long
-#  else
-#   define BDIGIT unsigned short
-#   define SIZEOF_BDIGIT (SIZEOF_LONG/2)
-#   define SIZEOF_ACTUAL_BDIGIT SIZEOF_LONG
-#   define BDIGIT_DBL unsigned long
-#  endif
-# endif
-# ifndef SIZEOF_ACTUAL_BDIGIT
-#  define SIZEOF_ACTUAL_BDIGIT SIZEOF_BDIGIT
-# endif
-
-# define BIGNUM_EMBED_LEN_NUMBITS 3
-# ifndef BIGNUM_EMBED_LEN_MAX
-#  if (SIZEOF_VALUE*3/SIZEOF_ACTUAL_BDIGIT) < (1 << BIGNUM_EMBED_LEN_NUMBITS)-1
-#    define BIGNUM_EMBED_LEN_MAX (SIZEOF_VALUE*3/SIZEOF_ACTUAL_BDIGIT)
-#  else
-#    define BIGNUM_EMBED_LEN_MAX ((1 << BIGNUM_EMBED_LEN_NUMBITS)-1)
-#  endif
-# endif
-
-struct RBignum {
-    struct RBasic basic;
-    union {
-        struct {
-            size_t len;
-            BDIGIT *digits;
-        } heap;
-        BDIGIT ary[BIGNUM_EMBED_LEN_MAX];
-    } as;
-};
-
-# define BIGNUM_SIGN_BIT FL_USER1
-/* sign: positive:1, negative:0 */
-# define BIGNUM_SIGN(b) ((RBASIC(b)->flags & BIGNUM_SIGN_BIT) != 0)
-# define BIGNUM_SET_SIGN(b,sign) \
-  ((sign) ? (RBASIC(b)->flags |= BIGNUM_SIGN_BIT) \
-          : (RBASIC(b)->flags &= ~BIGNUM_SIGN_BIT))
-# define BIGNUM_POSITIVE_P(b) BIGNUM_SIGN(b)
-# define BIGNUM_NEGATIVE_P(b) (!BIGNUM_SIGN(b))
-
-# define BIGNUM_EMBED_FLAG FL_USER2
-# define BIGNUM_EMBED_LEN_MASK (FL_USER5|FL_USER4|FL_USER3)
-# define BIGNUM_EMBED_LEN_SHIFT (FL_USHIFT+BIGNUM_EMBED_LEN_NUMBITS)
-# define BIGNUM_LEN(b) \
-    ((RBASIC(b)->flags & BIGNUM_EMBED_FLAG) ? \
-     (long)((RBASIC(b)->flags >> BIGNUM_EMBED_LEN_SHIFT) & \
-            (BIGNUM_EMBED_LEN_MASK >> BIGNUM_EMBED_LEN_SHIFT)) : \
-     RBIGNUM(b)->as.heap.len)
-/* LSB:BIGNUM_DIGITS(b)[0], MSB:BIGNUM_DIGITS(b)[BIGNUM_LEN(b)-1] */
-# define BIGNUM_DIGITS(b) \
-    ((RBASIC(b)->flags & BIGNUM_EMBED_FLAG) ? \
-     RBIGNUM(b)->as.ary : \
-     RBIGNUM(b)->as.heap.digits)
-# define BIGNUM_LENINT(b) rb_long2int(BIGNUM_LEN(b))
-
-# define RBIGNUM(obj) (R_CAST(RBignum)(obj))
-
-# define RBIGNUM_LEN(v) BIGNUM_LEN(v)
-# define RBIGNUM_DIGITS(v) BIGNUM_DIGITS(v)
-# define SIZEOF_BDIGITS SIZEOF_BDIGIT
-#endif
 
 //
 // The Ruby header file win32/win32.h defines a number of macros for
@@ -161,25 +80,4 @@ typedef VALUE(*ICE_RUBY_ENTRY_POINT)(...);
 #   define RFLOAT_VALUE(v) RFLOAT(v)->value
 #endif
 
-#ifndef RBIGNUM_LEN
-#   define RBIGNUM_LEN(v) RBIGNUM(v)->len
-#endif
-
-//
-// The definition of RBIGNUM_DIGITS in 1.8.7p248+ causes a compilation error (see bug 4653),
-// so we undefine it and use our own definition below. Note that the macro HAVE_RUBY_RUBY_H
-// is only defined in Ruby 1.9.
-//
-#ifndef HAVE_RUBY_RUBY_H
-#   undef RBIGNUM_DIGITS
-#endif
-
-#ifndef RBIGNUM_DIGITS
-#   define RBIGNUM_DIGITS(v) ((BDIGIT*)RBIGNUM(v)->digits)
-#endif
-
-#ifndef RBIGNUM_SIGN
-#   define RBIGNUM_SIGN(v) RBIGNUM(v)->sign
-#endif
-
 #endif
diff --git a/rb/src/IceRuby/Util.cpp b/rb/src/IceRuby/Util.cpp
index e7cfed1..aa2487b 100644
--- a/rb/src/IceRuby/Util.cpp
+++ b/rb/src/IceRuby/Util.cpp
@@ -308,73 +308,64 @@
 #endif
 }
 
+namespace
+{
+
+template <typename T> 
+struct RubyCallArgs
+{
+    VALUE val;
+    T ret;
+};
+
+//
+// Wrapper function to call rb_num2long with rb_protect
+//
+VALUE
+rb_num2long_wrapper(VALUE val)
+{
+    RubyCallArgs<long>* data = (RubyCallArgs<long>*)val;
+    data->ret = rb_num2long(data->val);
+    return val;
+}
+
+//
+// Wrapper function to call rb_num2ll with rb_protect
+//
+VALUE
+rb_num2ll_wrapper(VALUE val)
+{
+    RubyCallArgs<Ice::Long>* data = (RubyCallArgs<Ice::Long>*)val;
+    data->ret = rb_num2ll(data->val);
+    return val;
+}
+
+}
+
 long
 IceRuby::getInteger(VALUE val)
 {
-    if(!FIXNUM_P(val) && TYPE(val) != T_BIGNUM)
-    {
-        val = callRuby(rb_Integer, val);
-    }
-    if(FIXNUM_P(val))
-    {
-        return FIX2LONG(val);
-    }
-    else if(TYPE(val) == T_BIGNUM)
+    RubyCallArgs<long> arg= {val, -1};
+    int error = 0;
+    rb_protect(rb_num2long_wrapper, (VALUE)&arg, &error);
+    if(error)
     {
-        Ice::Long l = getLong(val);
-        if(l >= static_cast<Ice::Long>(INT_MIN) && l <= static_cast<Ice::Long>(INT_MAX))
-        {
-            return static_cast<long>(l);
-        }
+        throw RubyException(rb_eTypeError, "unable to convert value to an int");
     }
-    throw RubyException(rb_eTypeError, "unable to convert value to an integer");
+    return arg.ret;
 }
 
-#define BITSPERDIG (SIZEOF_BDIGITS*CHAR_BIT)
-#define BIGUP(x) ((BDIGIT_DBL)(x) << BITSPERDIG)
-
 Ice::Long
 IceRuby::getLong(VALUE val)
 {
-    //
-    // The rb_num2ll function raises exceptions, but we can't call it using callProtected
-    // because its return type is long long and not VALUE.
-    //
-    volatile VALUE v = callRuby(rb_Integer, val);
-    if(NIL_P(v))
+    RubyCallArgs<Ice::Long> arg= {val, -1};
+    int error = 0;
+    rb_protect(rb_num2ll_wrapper, (VALUE)&arg, &error);
+    if(error)
     {
         throw RubyException(rb_eTypeError, "unable to convert value to a long");
     }
-    if(FIXNUM_P(v))
-    {
-        return FIX2LONG(v);
-    }
-    else
-    {
-        assert(TYPE(v) == T_BIGNUM);
-        long len = RBIGNUM_LEN(v);
-        if(len > SIZEOF_LONG_LONG/SIZEOF_BDIGITS)
-        {
-            throw RubyException(rb_eRangeError, "bignum too big to convert into long");
-        }
-        BDIGIT *ds = RBIGNUM_DIGITS(v);
-        BDIGIT_DBL num = 0;
-        while(len--)
-        {
-            num = BIGUP(num);
-            num += ds[len];
-        }
-        Ice::Long l = static_cast<Ice::Long>(num);
-        if(l < 0 && (RBIGNUM_SIGN(v) || l != LLONG_MIN))
-        {
-            throw RubyException(rb_eRangeError, "bignum too big to convert into long");
-        }
-        if (!RBIGNUM_SIGN(v))
-        {
-            return -l;
-        }
-        return l;
-    }
+    return arg.ret;
 }
 
 bool
-- 
2.6.2

